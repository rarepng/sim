<!DOCTYPE html>
<html>
<head>
    <title>Wasm 3D Physics</title>
    <style> 
        body { margin: 0; overflow: hidden; background: #111; user-select: none; } 
        canvas { display: block; }
        /* Fix lil-gui position */
        .lil-gui { position: absolute; top: 0; right: 0; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="sim.js"></script>
    <script>
        Module().then(wasm => {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const ctx = canvas.getContext('2d');

            // --- 1. Initialize Physics World ---
            const world = new wasm.PhysicsWorld();
            
            // Create the Cloth (x, y, z, cols, rows, spacing, k, damp)
            world.createCloth(-400, -300, 0, 25, 20, 35, 1200, 10.0);

            // --- 2. Parameters & GUI ---
            const params = {
                // Sim
                timeScale: 1.0,
                subSteps: 8,
                
                // Forces
                gravity: 1000,
                windX: 0,
                windZ: 0,
                airResist: 0.99,

                // Material
                stiffness: 1200,
                damping: 10,
                
                // Camera
                autoRotate: false
            };

            const gui = new lil.GUI({ title: 'Physics Params' });
            
            const fSim = gui.addFolder('Simulation');
            fSim.add(params, 'timeScale', 0.1, 3.0, 0.1).name('Time Scale');
            fSim.add(params, 'subSteps', 1, 32, 1).onChange(v => world.setSubSteps(v));
            
            const fForces = gui.addFolder('Environment');
            fForces.add(params, 'gravity', -500, 2000).onChange(v => world.setGravity(0, v, 0));
            fForces.add(params, 'windX', -1000, 1000).onChange(v => world.setWind(v, 0, params.windZ));
            fForces.add(params, 'windZ', -1000, 1000).onChange(v => world.setWind(params.windX, 0, v));
            fForces.add(params, 'airResist', 0.9, 1.0).onChange(v => world.setDamping(v));

            const fMat = gui.addFolder('Material (Springs)');
            fMat.add(params, 'stiffness', 100, 5000).onChange(v => world.setSpringParams(v, params.damping));
            fMat.add(params, 'damping', 0, 100).onChange(v => world.setSpringParams(params.stiffness, v));

            gui.add(params, 'autoRotate');


            // --- 3. Interaction State ---
            let camAngleX = 0.2, camAngleY = 0.5, camZoom = 1800;
            const focalLength = 1000;
            
            let mouseX=0, mouseY=0;
            let isRotating=false, isGrabbing=false;
            let grabbedIdx=-1, grabDepth=0;

            // --- 4. 3D Math Helpers ---

            function project(x, y, z) {
                if(params.autoRotate && !isGrabbing) camAngleY += 0.005;

                const cy = Math.cos(camAngleY), sy = Math.sin(camAngleY);
                const cx = Math.cos(camAngleX), sx = Math.sin(camAngleX);

                // Rotate Y
                let rx = x * cy - z * sy;
                let rz = x * sy + z * cy;
                
                // Rotate X
                let ry = y * cx - rz * sx;
                rz = y * sx + rz * cx;

                // Translate Z
                rz += camZoom;

                if (rz <= 10) return null;

                const scale = focalLength / rz;
                return {
                    x: rx * scale + canvas.width / 2,
                    y: ry * scale + canvas.height / 2,
                    r: Math.max(2, 8 * scale),
                    z: rz,
                    scale: scale
                };
            }

            // Unproject: Mouse(2D) + Depth -> World(3D)
            function unproject(screenX, screenY, projectedZ) {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                const scale = focalLength / projectedZ;
                let rx = (screenX - cx) / scale;
                let ry = (screenY - cy) / scale;
                let rz = projectedZ - camZoom;

                // Undo X Rotation
                const cx_ = Math.cos(-camAngleX), sx_ = Math.sin(-camAngleX);
                let y_ = ry * cx_ - rz * sx_;
                let z_ = ry * sx_ + rz * cx_;
                ry = y_; rz = z_;

                // Undo Y Rotation
                const cy_ = Math.cos(-camAngleY), sy_ = Math.sin(-camAngleY);
                let x_ = rx * cy_ - rz * sy_;
                let z__ = rx * sy_ + rz * cy_;
                
                return { x: x_, y: ry, z: z__ };
            }

            // --- 5. Interaction Logic ---
            function attemptGrab() {
                const pPtr = world.getPPtr() >> 2; // Use getPPtr (from new C++)
                const buffer = wasm.HEAPF32;
                const count = world.getPCount();
                // Struct size is 8 floats in new C++ version (pos, old, acc)
                const stride = 8; 

                let minZ = Infinity;
                let found = -1;

                for(let i=0; i<count; ++i) {
                    const idx = pPtr + i*stride;
                    // Project pure position
                    const p = project(buffer[idx], buffer[idx+1], buffer[idx+2]);
                    if(!p) continue;

                    const dx = mouseX - p.x;
                    const dy = mouseY - p.y;
                    // Hit radius
                    if(dx*dx + dy*dy < (p.r + 15)**2) {
                        if(p.z < minZ) {
                            minZ = p.z;
                            found = i;
                            grabDepth = p.z;
                        }
                    }
                }
                if(found !== -1) grabbedIdx = found;
            }

            function moveGrabbed() {
                const pos = unproject(mouseX, mouseY, grabDepth);
                world.setParticlePos(grabbedIdx, pos.x, pos.y, pos.z);
            }

            // --- 6. Render Loop ---
            function render() {
                // Param: Time Scale
                world.update(0.016 * params.timeScale);

                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const bufferF = wasm.HEAPF32;
                const bufferI = wasm.HEAP32;
                
                const pPtr = world.getPPtr() >> 2;
                const sPtr = world.getSPtr() >> 2;
                const pCount = world.getPCount();
                const sCount = world.getSCount();
                const pStride = 8; // pos(3)+old(3)+acc(3) -> align 8 roughly? NO wait
                // In C++ struct: pos(3) + old(3) + acc(3) + mass(1) + pin(1) = 11 floats.
                // NOTE: Check your C++ struct alignment! 
                // Let's assume standard packing: 11 floats * 4 bytes = 44 bytes.
                // Be safe: Use the C++ getter if available, or assume 12 floats (48 bytes) for alignment.
                // Let's verify manually: 3+3+3+1+1 = 11. 
                // Using 11 works if alignment is loose.
                // If particles look glitchy, change this to 12.
                const realPStride = 11; 

                // 1. Project & Sort Particles
                const projected = [];
                for(let i=0; i<pCount; i++) {
                    const idx = pPtr + i * realPStride;
                    const p = project(bufferF[idx], bufferF[idx+1], bufferF[idx+2]);
                    if(p) {
                        p.i = i;
                        projected.push(p);
                    }
                }
                projected.sort((a,b) => b.z - a.z);

                // 2. Draw Springs (Wireframe)
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(80, 200, 255, 0.3)';
                ctx.beginPath();
                
                // Map for O(1) lookup
                const projMap = new Array(pCount);
                for(let p of projected) projMap[p.i] = p;

                // Spring stride in C++: int(2) + float(3) = 5 * 4 bytes = 20 bytes
                const sStride = 5; 

                for(let i=0; i<sCount; i++) {
                    const idx = sPtr + i * sStride;
                    const i1 = bufferI[idx];
                    const i2 = bufferI[idx+1];
                    const p1 = projMap[i1];
                    const p2 = projMap[i2];
                    if(p1 && p2) {
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                    }
                }
                ctx.stroke();

                // 3. Draw Particles (Volumetric Spheres)
                for(let p of projected) {
                    const r = p.r;
                    const grad = ctx.createRadialGradient(
                        p.x - r/3, p.y - r/3, r*0.2, 
                        p.x, p.y, r
                    );
                    
                    if(p.i === grabbedIdx) {
                        grad.addColorStop(0, '#ffaa00');
                        grad.addColorStop(1, '#aa4400');
                    } else {
                        grad.addColorStop(0, '#ffffff');
                        grad.addColorStop(1, '#444444');
                    }
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
                    ctx.fill();
                }

                if(isGrabbing && grabbedIdx !== -1) moveGrabbed();

                requestAnimationFrame(render);
            }
            render();

            // --- 7. Event Handlers ---
            canvas.onmousedown = e => {
                const r = canvas.getBoundingClientRect();
                mouseX = e.clientX - r.left; mouseY = e.clientY - r.top;
                if(e.button === 2 || e.ctrlKey) {
                    isGrabbing = true;
                    attemptGrab();
                } else {
                    isRotating = true;
                }
            };
            window.onmouseup = () => { isRotating=false; isGrabbing=false; grabbedIdx=-1; };
            canvas.onmousemove = e => {
                const r = canvas.getBoundingClientRect();
                const mx = e.clientX - r.left, my = e.clientY - r.top;
                const dx = mx - mouseX, dy = my - mouseY;
                mouseX = mx; mouseY = my;
                
                if(isRotating) {
                    camAngleY += dx * 0.005;
                    camAngleX += dy * 0.005;
                    camAngleX = Math.max(-1.5, Math.min(1.5, camAngleX));
                }
            };
            canvas.oncontextmenu = e => e.preventDefault();
        });
    </script>
</body>
</html>